//Teensy 4.0 code
//https://www.pjrc.com/store/teensy40.html


/*
  Exclusions for channels 0-3
  15
  271
  527
  783
  1039
  1295
  1551
  1807
  Channels 4-11 are just 8bit values, multiplication to full scale should work
  For simplicity all channels are considered as 8bit   
*/



#include "USBHost_t36.h"
//https://github.com/PaulStoffregen/USBHost_t36
//part of TeensyDuino 1.58
#include "sbus.h"
//https://github.com/bolderflight/sbus 
//v 8.1.4

uint8_t databyte[12];  //12 8-bit channels
bfs::SbusTx sbus_tx(&Serial3);
/* Array for storing SBUS data */
//std::array<int16_t, bfs::SbusRx::NUM_CH()> sbus_data;
bfs::SbusData sbus_data;


USBHost myusb;
USBHub hub1(myusb);
USBHIDParser hid1(myusb);

#define COUNT_JOYSTICKS 4
JoystickController joysticks[COUNT_JOYSTICKS] = {
  JoystickController(myusb), JoystickController(myusb),
  JoystickController(myusb), JoystickController(myusb)
};
int user_axis[64];
uint32_t buttons_prev = 0;

USBDriver *drivers[] = { &hub1, &joysticks[0], &joysticks[1], &joysticks[2], &joysticks[3], &hid1 };
#define CNT_DEVICES (sizeof(drivers) / sizeof(drivers[0]))
const char *driver_names[CNT_DEVICES] = { "Hub1", "joystick[0D]", "joystick[1D]", "joystick[2D]", "joystick[3D]", "HID1" };
bool driver_active[CNT_DEVICES] = { false, false, false, false };

// Lets also look at HID Input devices
USBHIDInput *hiddrivers[] = { &joysticks[0], &joysticks[1], &joysticks[2], &joysticks[3] };
#define CNT_HIDDEVICES (sizeof(hiddrivers) / sizeof(hiddrivers[0]))
const char *hid_driver_names[CNT_DEVICES] = { "joystick[0H]", "joystick[1H]", "joystick[2H]", "joystick[3H]" };
bool hid_driver_active[CNT_DEVICES] = { false };
bool show_changed_only = false;

uint8_t joystick_left_trigger_value[COUNT_JOYSTICKS] = { 0 };
uint8_t joystick_right_trigger_value[COUNT_JOYSTICKS] = { 0 };
uint64_t joystick_full_notify_mask = (uint64_t)-1;

int psAxis[64];
//int minaxis, maxaxis, mintrig, maxtrig;

uint8_t button[6];
uint16_t buttmp;



//=============================================================================
// Setup
//=============================================================================
void setup() {
  /* Begin the SBUS communication */
  databyte[0] = 127;
  databyte[1] = 127;
  databyte[2] = 0;
  databyte[3] = 127;
  databyte[4] = 127;
  databyte[5] = 0;
  databyte[6] = 0;
  databyte[7] = 0;
  databyte[8] = 4; //sbus data are generated by transmitter program
  databyte[9] = 0;
  databyte[10] = 0;
  databyte[11] = 0;
  for (uint8_t i = 0; i < 12; i++) {
    sbus_data.ch[i] = databyte[i] * 8;
  }
  
  sbus_tx.Begin();
  sbus_tx.data(sbus_data);
  sbus_tx.Write();

  Serial.begin(115200);

  Serial.println("PS4 GHOST RCJOY STARTING");
  myusb.begin();
}


//=============================================================================
// loop
//=============================================================================
void loop() {
  myusb.Task();



  //  for (int joystick_index = 0; joystick_index < COUNT_JOYSTICKS; joystick_index++)
  //    joysticks[joystick_index].axisChangeNotifyMask(joystick_full_notify_mask);

  for (int joystick_index = 0; joystick_index < COUNT_JOYSTICKS; joystick_index++)
    joysticks[joystick_index].axisChangeNotifyMask(0xffffffffffffffff);

  for (int joystick_index = 0; joystick_index < COUNT_JOYSTICKS; joystick_index++) {
    if (joysticks[joystick_index].available()) {
      //uint64_t axis_mask = joysticks[joystick_index].axisMask();
      //uint64_t axis_changed_mask = joysticks[joystick_index].axisChangedMask();
      uint32_t buttons = joysticks[joystick_index].getButtons();
      //Serial.printf("Joystick(%d): buttons = %x", joystick_index, buttons);
      //for (uint8_t i = 0; axis_mask != 0; i++, axis_mask >>= 1) {
      //  if (axis_mask & 1) {
      //    Serial.printf(" %d:%d", i, joysticks[joystick_index].getAxis(i));
      //    Serial.println();
      //  }
      //}
      switch (joysticks[joystick_index].joystickType()) {
        default:
          break;
        case JoystickController::PS4:
          {
            databyte[0] = joysticks[joystick_index].getAxis(0);
            databyte[1] = joysticks[joystick_index].getAxis(1);
            databyte[2] = joysticks[joystick_index].getAxis(3);
            databyte[3] = joysticks[joystick_index].getAxis(2);
            databyte[4] = joysticks[joystick_index].getAxis(5);
            databyte[5] = joysticks[joystick_index].getAxis(4);

            databyte[6] = 1 * (buttons & 0x0002) / 0x0002 +   //A CROSS
                          2 * (buttons & 0x0004) / 0x0004 +   //B CIRCLE
                          4 * (buttons & 0x0001) / 0x0001 +   //X SQUARE
                          8 * (buttons & 0x0008) / 0x0008 +   //Y TRIANGLE
                          16 * (buttons & 0x0010) / 0x0010 +  //LTRIG
                          32 * (buttons & 0x0020) / 0x0020 +  //RTRIG
                          64 * (buttons & 0x0100) / 0x0100 +  //SHARE
                          128 * (buttons & 0x0200) / 0x0200;  //RHAT
                                                              //64 * (buttons & 0x0400) / 0x0400 + //LHAT
                                                              //128 * (buttons & 0x0800) / 0x0800; //RHAT
            //databyte[7] = 0;
            databyte[7] = 0 + 1 * (buttons & 0x1000) / 0x1000 +  //PS
                          2 * (buttons & 0x0400) / 0x0400 +      //LHAT
                          4 * (buttons & 0x0800) / 0x0800 +      //RHAT
                          8 * (buttons & 0x2000) / 0x2000;       //TOUCH

            //databyte[8] = ((joysticks[joystick_index].getAxis(9) & 0b00000111) + 1);
            uint8_t hat = joysticks[joystick_index].getAxis(9);
            //(hat == 8) ? databyte[8] = 0 : (databyte[8] = hat + 1) * 16;
            if (hat != 8) databyte[7] += (hat + 1) * 16;
            /*databyte[8] = 0;
            switch (joysticks[joystick_index].getAxis(9)) {
              case 0: databyte[8] += 1; break;
              case 1: databyte[8] += 2; break;
              case 2: databyte[8] += 3; break;
              case 3: databyte[8] += 4; break;
              case 4: databyte[8] += 5; break;
              case 5: databyte[8] += 6; break;
              case 6: databyte[8] += 7; break;
              case 7: databyte[8] += 8; break;
              case 8: databyte[8] += 0; break;
              default: break;
            }
            */
            //databyte[8]=4;


            for (uint8_t n = 0; n < 12; n++) {
              Serial.println(databyte[n]);
            }
            Serial.println();
            //Serial.println(millis());
          }
          for (uint8_t i = 0; i < 12; i++) {
            sbus_data.ch[i] = databyte[i] * 8;
          }
          sbus_data.ch[8]=32; //sbus data are generated by transmitter program
          sbus_tx.data(sbus_data);
          sbus_tx.Write();

          Serial.println();
          joysticks[joystick_index].joystickDataClear();
      }
    }
  }
  PrintDeviceListChanges();
  delay(20);
}

//=============================================================================
// Show when devices are added or removed
//=============================================================================
void PrintDeviceListChanges() {
  for (uint8_t i = 0; i < CNT_DEVICES; i++) {
    if (*drivers[i] != driver_active[i]) {
      databyte[0] = 127;
      databyte[1] = 127;
      databyte[2] = 0;
      databyte[3] = 127;
      databyte[4] = 127;
      databyte[5] = 0;
      databyte[6] = 0;
      databyte[7] = 0;
      databyte[8] = 4; //sbus data are generated by transmitter program
      databyte[9] = 0;
      databyte[10] = 0;
      databyte[11] = 0;
      for (uint8_t i = 0; i < 12; i++) {
        sbus_data.ch[i] = databyte[i] * 8;
      }
      sbus_tx.data(sbus_data);
      sbus_tx.Write();

      if (driver_active[i]) {
        Serial.printf("*** Device %s - disconnected ***\n", driver_names[i]);
        driver_active[i] = false;

      } else {
        Serial.printf("*** Device %s %x:%x - connected ***\n", driver_names[i], drivers[i]->idVendor(), drivers[i]->idProduct());
        driver_active[i] = true;

        const uint8_t *psz = drivers[i]->manufacturer();
        if (psz && *psz) Serial.printf("  manufacturer: %s\n", psz);
        psz = drivers[i]->product();
        if (psz && *psz) Serial.printf("  product: %s\n", psz);
        psz = drivers[i]->serialNumber();
        if (psz && *psz) Serial.printf("  Serial: %s\n", psz);
      }
    }
  }

  for (uint8_t i = 0; i < CNT_HIDDEVICES; i++) {
    if (*hiddrivers[i] != hid_driver_active[i]) {
      databyte[0] = 127;
      databyte[1] = 127;
      databyte[2] = 0;
      databyte[3] = 127;
      databyte[4] = 127;
      databyte[5] = 0;
      databyte[6] = 0;
      databyte[7] = 0;
      databyte[8] = 4; //sbus data are generated by transmitter program
      databyte[9] = 0;
      databyte[10] = 0;
      databyte[11] = 0;
      for (uint8_t i = 0; i < 12; i++) {
        sbus_data.ch[i] = databyte[i] * 8;
      }
      sbus_tx.data(sbus_data);
      sbus_tx.Write();

      if (hid_driver_active[i]) {
        Serial.printf("*** HID Device %s - disconnected ***\n", hid_driver_names[i]);
        hid_driver_active[i] = false;

      } else {
        Serial.printf("*** HID Device %s %x:%x - connected ***\n", hid_driver_names[i], hiddrivers[i]->idVendor(), hiddrivers[i]->idProduct());
        hid_driver_active[i] = true;

        const uint8_t *psz = hiddrivers[i]->manufacturer();
        if (psz && *psz) Serial.printf("  manufacturer: %s\n", psz);
        psz = hiddrivers[i]->product();
        if (psz && *psz) Serial.printf("  product: %s\n", psz);
        psz = hiddrivers[i]->serialNumber();
        if (psz && *psz) Serial.printf("  Serial: %s\n", psz);
      }
    }
  }
}